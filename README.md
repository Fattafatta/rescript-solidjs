# rescript-solidjs

## Note

This library is in **experimental** state. A lot of stuff is untested and some of the bindings may simply not work. Feedback is always welcome.

---

`rescript-solidjs` allows the use of [solidJs](https://github.com/solidjs/solid) with [ReScript](https://rescript-lang.org/) while still using `JSX`. It provides bindings for most of the `solidJs` feature set (see list of missing stuff below). And it also contains the necessary modules, to make the `ReScript` compiler produce `HyperScript` code that is compatible with `solidJs`.

## Background

Normally, `ReScript` compiles `JSX` directly to `JavaScript`. Therefore it is incompatible with `solidJs` since it expects the `JSX` to still be intact and uses their own compiler.
Luckily `solidJs` also supports its [own](https://github.com/solidjs/solid/tree/main/packages/solid/h) version of `HyperScript` which could be used together with `ReScript` and some additional bindings. But using `HyperScript` instead of `JSX` is not a great developer experience.

Normally it would be necessary to develop a ppx to modify the behavior of the `ReScript` compiler, but instead the library uses its own fake version of [rescript-react](https://github.com/rescript-lang/rescript-react) bindings to create the necessary bridge between the code generated by `ReScript` and the `HyperScript` expected from `solidJs`.

Basically the `React.createElement` function provided by the fake react is replaced by the `h` function from `HyperScript`. Most of the magic happens in the `src/react/hyper.js` file. The rest of the library consists of all the react types required by the `ReScript` compiler, and the actual `solidJs` bindings.

## Installation

We have to trick `ReScript` to accept this library as a replacement for the original react bindings. This can be accomplished by using a module alias.

Install with `npm`:

```bash
npm install solid-js @fattafatta/rescript-solidjs react@npm:@fattafatta/rescript-solidjs
```

Or install with `yarn`:

```bash
yarn add solid-js @fattafatta/rescript-solidjs react@npm:@fattafatta/rescript-solidjs
```

Add `@fattafatta/rescript-solidjs` as a dependency to your `bsconfig.json`:

```json
"bs-dependencies": ["@fattafatta/rescript-solidjs"]
```

Make sure to **remove** `@rescript/react` if it is already listed. It is impossible to use this library and the original react binding together.

Your `package.json` dependencies should look similar to this:

```json
"dependencies": {
  "@fattafatta/rescript-solidjs": "^0.1.0",
  "react": "npm:@fattafatta/rescript-solidjs@^0.1.0",
  "rescript": "^9.1.4",
  "solid-js": "^1.4.3",
}
```

## Usage

The namings of the bindings are as close as possible to the original `solidJs` names. In some cases some deviations were necessary to better fit the `ReScript` type system.

### Quick example

A simple counter component.
(Note: Building a counter component is actually very tricky in react. But in `solidJs` it's really straightforward and behaves exactly as expected.)

```rescript
@react.component
let make = () => {
  let (count, setCount) = Solid.createSignal(1, ())

  let timer = Js.Global.setInterval(() => {
    setCount(c => c + 1)
  }, 1000)

  Solid.onCleanup(() => Js.Global.clearInterval(timer))

  <div>
    {Solid.track(() => `Hello ReScripters! Counter: ${Js.Int.toString(count())}`->React.string)}
    <button
      onClick={ReactDOM.On.asFunc(_ => {
        setCount(c => c - 3)
      })}>
      {"Decrease"->React.string}
    </button>
  </div>
}
```

### Basic reactivity

`solidJs`' HyperScript requires that all reactive props and children are wrapped in a function (`unit => 'returnValue`). But adding those functions would completely mess up the `ReScript` type system. The current solution is to wrap any reactive code with the `Solid.track()` function.
(This function adds no additional overhead and will be removed by the complier. It's only purpose is to make the types match.)

```rescript
// GOOD
{Solid.track(() => (count()->React.int))}

// BAD, this count would never update
{count()->React.int}
```

#### createSignal

The original `~options` argument is polymorphic. Use either the `#bool` or the `#fn` polymorphic variant to set them.

```rescript
// normal
let (count, setCount) = Solid.createSignal(1, ())

// with equality options
let (count, setCount) = Solid.createSignal(1, ~options=#bool({equals: false}), ())
// or with equality fn
let (count, setCount) = Solid.createSignal(1, ~options=#fn({equals: (prev, next) => prev == next}), ())
```

#### createEffect

```rescript
let (a, setA) = Solid.createSignal("initialValue", ());

// effect that depends on signal `a`
Solid.createEffect(() => Js.log(a()), ())
```

#### createMemo

Supports the same `~options` as `createSignal`.

```rescript
let value = Solid.createMemo((_) => computeExpensiveValue(a(), b()), ());

// set an initial value
let value = Solid.createMemo((_) => computeExpensiveValue(a(), b()), ~value=1, ());

// with options
let value = Solid.createMemo((_) => computeExpensiveValue(a(), b()), ~options=#bool({equals: false}), ());
```

### Events (e.g. onClick)

Solid offers an optimized array-based alternative to adding normal event listeners. In order to support this syntax a wrapper function `Event.asArray` has to be used.

```rescript
// solid's special array syntax
<button onClick={Solid.Event.asArray((s => Js.log(s), "Hello"))}>
  {"Click Me!"->React.string}
</button>

// normal event syntax
<button  onClick={Solid.Event.asFn(e => Js.log("Hello"))}>
  {"Click Me!"->React.string}
</button>

// BAD, this will not work
<button  onClick={e => Js.log("Hello")}>
  {"Click Me!"->React.string}
</button>
```

### Lifecycles

All lifecycle functions are supported.

### Reactive Utilities

Most utilities are supported.

#### mergeProps

ReScript does not offer the same flexibility for structural types as TypeScript does. The `mergeProps` function accepts any type without complaint, but it only works with records and objects. Also the compiler will have a hard time figuring out the correct type of the return value.

It is very easy to build breakable code with this function. Use with caution!

```rescript
type first = {first: int}
type second = {second: string}
let merged = Solid.mergeProps({first: 1}, {second: ""})
```

#### splitProps

Supported but untested. The original function expects an arbitrary number of parameters. In `ReScript` we have different functions `splitPropsN` to model that.

This function also easily breaks your code if used incorrectly!

```rescript
let split = Solid.splitProps2({first: 1, second: ""}, ["first"], ["second"])
```

### Stores

The `createStore` function is called `Solid.Store.make`, since this is a more idiomatic naming for `ReScript`.

```rescript
let (state, setState) = Solid.Store.make({greeting: "Hello"})
```

Solid's setState supports numerous practical ways to update the state. Since the function is so overloaded it is very hard to create bindings for it. Currently only the basic function syntax is supported.

```rescript
setState(state => {greeting: state.greeting ++ "!"})
```

#### unwrap

```rescript
let untracked = Solid.Store.unwrap(state)
```

### Component APIs

`children` and `createUniqueId` should work.

### Context

Context is currently not working.

### Secondary Primitives

All are untested. `createDeferred` does not support the `timeoutMs` option yet.

### createReaction

```rescript
let (s, set) = Solid.createSignal("start", ())
let track = Solid.createReaction(() => Js.log("something"))
track(() => s()->ignore)
```

### Rendering

`render` is working. All other functions are completely untested und might not work.

#### render

Attaches the root component to the DOM.

```rescript
Solid.render(() => <App />, Document.querySelector("#root")->Belt.Option.getExn, ())

// or with dispose
let dispose = Solid.render(() => <App />, Document.querySelector("#root")->Belt.Option.getExn)
```

#### DEV

Is named `dev` in rescript, and treated as `bool`.

### Control Flow

These helper components always expect reactive syntax (e.g. props have to we wrapped in `() => 'a`). Therefore it is not necessary to wrap the `each` or `when` with a `track`.

#### For

```rescript
<Solid.For each={() => ["Arya", "Jon", "Brandon"]} fallback={<div> {"Loading..."->React.string} </div>}>
  {(item, _) => <div> {`${item} Stark`->React.string} </div>}
</Solid.For>
```

#### Show

SolidJs' `Show` can be used with any truthy or falsy (like `null`) value. The concept of a truthy value does not translate well to `ReScript`, so instead `Show` expects an `option<'t>`.

```rescript
<Solid.Show.Option \"when"={() => Some({"greeting": "Hello!"})} fallback={<div> {"Loading..."->React.string} </div>}>
  {item => <div> {item["greeting"]->React.string} </div>}
</Solid.Show.Option>
```

In those cases where the `when` clause contains an actual `bool` a different version of `Show` has to be used:

```rescript
<Solid.Show.Bool \"when"={() => something > 0} fallback={<div> {"Loading..."->React.string} </div>}>
   <div> {"Hello!"->React.string} </div>
</Solid.Show.Bool>
```

#### Index

```rescript
<Solid.Index each={() => ["Arya", "Jon", "Brandon"]} fallback={<div> {"Loading..."->React.string} </div>}>
  {(item, _) => <div> {`${item()} Stark`->React.string} </div>}
</Solid.Index>
```

#### Switch/Match

ReScript offers great pattern matching. Use that instead.

#### ErrorBoundary

Only the variant with a fallback function is supported.

```rescript
<Solid.ErrorBoundary fallback={(_, _) => <div> {"Something went terribly wrong"->React.string} </div>}>
  <MyComp />
</Solid.ErrorBoundary>
```

#### Suspense

```rescript
<Solid.Suspense fallback={<div> {"Loading..."->React.string} </div>}> <AsyncComp /> </Solid.Suspense>
```

### Special JSX Attributes

Custom directives are not supported.

#### ref

Refs require function syntax.

```rescript
@react.component
let make = () => {
  let myRef = ref(Js.Nullable.null)

  <div ref={el => {myRef := el}} />
}
```

#### classList

`classList` behaves differently. Instead of an object it uses tuples of `(string, bool)`. It uses a thin wrapper to convert the tuples into an object. (Remember to use `Solid.track` if the list ist reactive)

```rescript
<div classList={Solid.track(() => Solid.makeClassList([("first", val() == 0), ("other", val() != 0)]))} />
```

#### style

`style` only supports string syntax right now.

```rescript
<div style={`background-color: green; height: 100px`} />
```

#### on...

See Events section above.

## Examples

Please check the `examples` folder for a complete project configured with `ReScript`, `solidJs` and `vite`.

## Missing features

For these features no bindings exist yet.

- createResource
- on
- observable
- from
- produce
- reconcile
- createMutable
- createContext
- useContext
- lazy
- createSelector
- all stuff related to hydration is untested
- renderToStream
- Dynamic
- custom directives
- /_ @once _/

## Acknowledgments

This library used multiple sources for inspiration. Especially <https://github.com/woeps/solidjs-rescript> was of great help to get the initial version going. It proved that `ReScript` and `solidJs` could work together when using `HyperScript`. The *only* missing step was to make the `ReScript` compiler produce `HyperScript`, to that `JSX` would work too.

### Additional info

Discussion about `ReScript` on github:
<https://github.com/solidjs/solid/discussions/330#discussioncomment-339972>

Discussion about `solidJs` in the `ReScript` forums:
<https://forum.rescript-lang.org/t/change-jsx-output-from-react-to-solidjs/1930/12>
